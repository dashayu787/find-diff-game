<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>97 Encontre as Diferen√ßas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #f0f0f0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #game-container {
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
</head>
<body>
  <div id="game-container"></div>

  <script>
    // ------------------------------------------------------------
    // Configura√ß√£o base
    // ------------------------------------------------------------
    const BASE_WIDTH  = 360;
    const BASE_HEIGHT = 720;
    const IMAGE_H_RATIO = 0.42; // cada imagem ocupa ~42% da altura
    const HIT_RADIUS_BASE = 25; // raio de acerto em unidades "base"

    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: BASE_WIDTH,
        height: BASE_HEIGHT
      },
      backgroundColor: '#f0f0f0',
      scene: { preload, create }
    };

    // ------------------------------------------------------------
    // Estado do jogo
    // ------------------------------------------------------------
    let timeLeft = 60;
    let score = 0;
    let gameOver = false;

    let timerText;
    let scoreText;
    let titleText;

    let topImage, bottomImage;
    let topY0, bottomY0; // topo (y) das imagens na tela
    let hitRadiusWorld;

    // Pontos de diferen√ßa (coordenadas base, relativas √† imagem de cima)
    const differencePointsBase = [
      { x: 100, y: 120 },
      { x: 250, y: 300 },
      { x: 180, y: 180 }
    ];

    // Normalizamos os pontos para 0..1 (u,v), para independ√™ncia de tela
    // u relativo √† largura base, v relativo √† altura *da imagem* (n√£o da tela)
    const points = differencePointsBase.map(p => ({
      u: p.x / BASE_WIDTH,
      v: p.y / (BASE_HEIGHT * IMAGE_H_RATIO)
    }));

    const foundSet = new Set();
    let timerEvt;

    const game = new Phaser.Game(config);

    // ------------------------------------------------------------
    // Preload
    // ------------------------------------------------------------
    function preload() {
      // ATEN√á√ÉO: verifique se o .png.png √© intencional
      this.load.image('topImage',    'https://cdn.jsdelivr.net/gh/dashayu787/my-image-cdn/img/level1_a.png.png');
      this.load.image('bottomImage', 'https://cdn.jsdelivr.net/gh/dashayu787/my-image-cdn/img/level1_b.png.png');

      this.load.atlas('flares',
        'https://labs.phaser.io/assets/particles/flares.png',
        'https://labs.phaser.io/assets/particles/flares.json'
      );

      // Indicador simples de progresso (opcional)
      const sw = this.scale.width, sh = this.scale.height;
      const barW = sw * 0.6, barH = 8;
      const x = (sw - barW) / 2, y = sh * 0.5;

      const loadBg = this.add.rectangle(x, y, barW, barH, 0xd0d0d0).setOrigin(0, 0.5);
      const loadFg = this.add.rectangle(x, y, 0,    barH, 0x009739).setOrigin(0, 0.5);

      this.load.on('progress', v => loadFg.width = barW * v);
      this.load.on('complete', () => { loadBg.destroy(); loadFg.destroy(); });
    }

    // ------------------------------------------------------------
    // Create
    // ------------------------------------------------------------
    function create() {
      const scene = this;
      const sw = this.scale.width;
      const sh = this.scale.height;

      // Raio de acerto em "pixels do mundo"
      hitRadiusWorld = HIT_RADIUS_BASE * (sw / BASE_WIDTH);

      // Imagens (preenchem 100% da largura; altura = 42% da tela)
      topImage = this.add.image(sw / 2, sh * 0.21, 'topImage')
                        .setDisplaySize(sw, sh * IMAGE_H_RATIO);

      bottomImage = this.add.image(sw / 2, sh * 0.75, 'bottomImage')
                           .setDisplaySize(sw, sh * IMAGE_H_RATIO);

      // Topos reais (y) de cada imagem, sem "n√∫meros m√°gicos"
      topY0    = topImage.y    - topImage.displayHeight / 2;
      bottomY0 = bottomImage.y - bottomImage.displayHeight / 2;

      // Barra do meio (fundo verde - verde do Brasil)
      const yBar = sh * 0.46 + 8;
      this.add.rectangle(sw / 2, yBar + 10, sw * 0.95, 40, 0x009739).setOrigin(0.5);

      // TMP
      timerText = this.add.text(sw * 0.05, yBar, 'TMP: 60', {
        fontSize: '12px', fill: '#FFD700', fontStyle: 'bold'
      }).setOrigin(0, 0);

      // T√≠tulo
      titleText = this.add.text(sw * 0.5, yBar, '97 Diferen√ßas', {
        fontSize: '16px', fill: '#FFD700', fontStyle: 'bold'
      }).setOrigin(0.5, 0);

      // PTS
      scoreText = this.add.text(sw * 0.95, yBar, 'PTS: 0', {
        fontSize: '12px', fill: '#FFD700', fontStyle: 'bold'
      }).setOrigin(1, 0);

      // Input
      const onPointerDown = (pointer) => {
        if (gameOver) return;

        const mx = pointer.x;
        const my = pointer.y;

        for (let i = 0; i < points.length; i++) {
          if (foundSet.has(i)) continue;

          const u = points[i].u;
          const v = Phaser.Math.Clamp(points[i].v, 0, 1); // seguran√ßa

          // Posi√ß√µes do "alvo" nas duas imagens (em coordenadas do mundo)
          const pxWorld = u * sw;
          const pyTopWorld    = topY0    + v * topImage.displayHeight;
          const pyBottomWorld = bottomY0 + v * bottomImage.displayHeight;

          const dTop    = Phaser.Math.Distance.Between(mx, my, pxWorld, pyTopWorld);
          const dBottom = Phaser.Math.Distance.Between(mx, my, pxWorld, pyBottomWorld);

          if (dTop <= hitRadiusWorld || dBottom <= hitRadiusWorld) {
            // Registrou acerto
            foundSet.add(i);
            score++;
            scoreText.setText('PTS: ' + score);

            // Marca nas duas imagens
            drawHit.call(scene, pxWorld, pyTopWorld);
            drawHit.call(scene, pxWorld, pyBottomWorld);

            // Todos encontrados?
            if (score >= points.length) {
              endGame.call(scene, true);
            }
            return;
          }
        }
      };

      this.input.on('pointerdown', onPointerDown);

      // Timer 1s
      timerEvt = this.time.addEvent({
        delay: 1000,
        loop: true,
        callback: () => {
          if (gameOver) return;
          timeLeft--;
          const color = timeLeft <= 10 ? '#ff0000' : '#FFD700';
          timerText.setText('TMP: ' + timeLeft);
          timerText.setColor(color);
          if (timeLeft <= 0) {
            endGame.call(scene, false);
          }
        }
      });
    }

    // ------------------------------------------------------------
    // Helpers
    // ------------------------------------------------------------
    function drawHit(x, y) {
      const r = Math.max(10, hitRadiusWorld * 0.5);

      // C√≠rculo preenchido
      const c = this.add.circle(x, y, r, 0xff0000, 0.6);

      // Anel de destaque com tween
      const ring = this.add.circle(x, y, r + 4, 0xff0000, 0)
                          .setStrokeStyle(2, 0xff0000, 0.9);

      this.tweens.add({
        targets: ring,
        scale: 1.4,
        alpha: 0,
        duration: 500,
        onComplete: () => ring.destroy()
      });
    }

    function endGame(win) {
      if (gameOver) return;
      gameOver = true;

      // Desativa input e timer
      this.input.enabled = false;
      if (timerEvt) {
        timerEvt.remove(false);
        timerEvt = null;
      }

      const sw = this.scale.width;
      const sh = this.scale.height;

      const msg = win
        ? `üéâ Fim de jogo!\nPTS: ${score}/${points.length} üéâ`
        : `‚è±Ô∏è Tempo esgotado!\nPTS: ${score}/${points.length}`;

      this.add.text(sw / 2, sh * 0.5, msg, {
        fontSize: '22px',
        fill: '#ffffff',
        backgroundColor: win ? '#4CAF50' : '#ff5252',
        align: 'center',
        padding: { x: 12, y: 10 }
      }).setOrigin(0.5);

      // Confete (para ambos os casos ‚Äî fica bonito üòÑ)
      const particles = this.add.particles('flares');
      const emitter = particles.createEmitter({
        frame: ['red', 'green', 'blue', 'yellow'],
        x: { min: 0, max: sw },
        y: 0,
        lifespan: 2000,
        speedY: { min: 200, max: 400 },
        scale: { start: 0.5, end: 0 },
        quantity: 4,
        blendMode: 'ADD'
      });

      this.time.delayedCall(3000, () => {
        emitter.stop();
        this.time.delayedCall(1000, () => particles.destroy());
      });
    }
  </script>
</body>
</html>
